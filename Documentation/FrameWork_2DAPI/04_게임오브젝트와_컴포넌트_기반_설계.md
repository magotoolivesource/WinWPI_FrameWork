FrameWork_2DAPI 문서 4: 게임오브젝트와 컴포넌트 기반 설계
이제 프레임워크의 가장 핵심적인 설계 패턴인 **컴포넌트 기반 아키텍처(Component-Based Architecture)**를 구현할 차례입니다. 이 모델은 게임 세계에 존재하는 모든 오브젝트를 '속성'과 '동작'의 조합으로 바라봅니다. GameObject는 빈 껍데기(Container)이고, Component는 이 껍데기에 부착하여 특정 기능(예: 렌더링, 이동, 충돌)을 부여하는 부품입니다.

이 방식은 상속(Inheritance) 기반 설계의 단점을 보완하고 코드의 유연성과 재사용성을 극대화합니다.

1. Component 기본 클래스 구현
모든 컴포넌트의 기반이 될 추상 클래스 Component를 먼저 정의합니다. Component 클래스는 자신을 소유한 GameObject에 대한 참조(owner)를 가지며, 모든 GameObject가 공유하는 생명주기(Lifecycle) 함수들을 가상 함수(virtual function)로 정의합니다.

Component.h
#pragma once
#include <windows.h> // HDC 사용을 위해

class GameObject; // GameObject를 전방 선언하여 순환 참조 방지
class Transform;

class Component abstract // 추상 클래스로 선언
{
public:
    GameObject* owner = nullptr;    // 이 컴포넌트를 소유한 GameObject
    Transform* transform = nullptr; // owner의 Transform 컴포넌트에 대한 바로 가기

protected:
    bool enabled = true; // 컴포넌트의 활성화 여부

public:
    Component() = default;
    virtual ~Component() = default; // 가상 소멸자

    // --- 생명주기(Lifecycle) 함수 ---

    // 컴포넌트가 GameObject에 추가될 때 호출
    virtual void Initialize_AddCompoment();
    
    // 씬이 시작될 때, 첫 Update 직전에 한 번 호출
    virtual void Start() {}

    // 매 프레임 호출
    virtual void Update(float dt) {}

    // 매 프레임 Update 이후 호출 (그리기용)
    virtual void Render(HDC hdc) {}

    // 컴포넌트가 GameObject에서 제거될 때 호출
    virtual void RemoveCompoment();

    // 활성화/비활성화
    void SetEnabled(bool e) { enabled = e; }
    bool IsEnabled() const { return enabled; }
};
owner: Component가 어떤 GameObject에 속해 있는지 알아야 다른 Component에 접근하거나 GameObject의 상태를 변경할 수 있습니다.
transform: 위치, 회전, 크기는 거의 모든 Component가 필요로 하는 매우 기본적인 정보이므로, 매번 owner->GetComponent<Transform>()을 호출하는 대신 빠르게 접근할 수 있도록 바로 가기 포인터를 둡니다.
2. GameObject 클래스 구현
GameObject는 Component들을 담는 컨테이너 역할을 합니다. std::vector나 std::map을 사용하여 여러 Component를 관리하며, 이들의 생명주기 함수를 적절한 시점에 호출해주는 역할을 합니다.

GameObject.h
#pragma once
#include <string>
#include <vector>
#include <memory>       // unique_ptr 사용
#include <unordered_map> // map 사용
#include <typeindex>    // typeid를 map의 키로 사용

#include "Component.h" // Component 클래스 포함

class GameObject
{
protected:
    // 컴포넌트들을 타입 정보(type_index)를 키로 하여 저장
    std::unordered_map<std::type_index, std::unique_ptr<Component>> m_components;
    
    // 매 프레임 순회할 활성화된 컴포넌트 목록 (성능 최적화용)
    std::vector<Component*> m_activeComponents;

public:
    // 모든 GameObject는 Transform을 가짐
    Transform* transform = nullptr;
    std::string name;
    bool active = true;

public:
    GameObject();
    virtual ~GameObject();

    // --- 생명주기 함수 ---
    void Start();
    void Update(float dt);
    void Render(HDC hdc);

    // --- 컴포넌트 관리 함수 ---

    // 템플릿을 사용하여 컴포넌트를 추가하는 함수
    template <typename T, typename... Args>
    T* AddComponent(Args&&... args);

    // 템플릿을 사용하여 컴포넌트를 가져오는 함수
    template <typename T>
    T* GetComponent();
};

// --- 템플릿 함수 구현 (헤더 파일에 위치해야 함) ---

template<typename T, typename ...Args>
inline T* GameObject::AddComponent(Args && ...args)
{
    // T 타입의 컴포넌트를 생성
    auto newComponent = std::make_unique<T>(std::forward<Args>(args)...);
    
    // owner 설정
    newComponent->owner = this;
    
    // 컴포넌트 맵에 추가
    T* rawPtr = newComponent.get();
    m_components[std::type_index(typeid(T))] = std::move(newComponent);

    // 초기화 함수 호출
    rawPtr->Initialize_AddCompoment();

    // 활성 컴포넌트 목록에도 추가 (실제로는 지연 추가 방식이 더 안전)
    m_activeComponents.push_back(rawPtr);

    return rawPtr;
}

template<typename T>
inline T* GameObject::GetComponent()
{
    auto it = m_components.find(std::type_index(typeid(T)));
    if (it != m_components.end()) {
        // dynamic_cast를 사용하여 안전하게 타입 변환
        return dynamic_cast<T*>(it->second.get());
    }
    return nullptr;
}
std::unique_ptr: GameObject가 Component의 소유권을 독점하도록 하여 메모리 관리를 자동화합니다. GameObject가 파괴될 때 unique_ptr이 소멸하면서 Component도 함께 파괴됩니다.
std::unordered_map: 특정 타입의 Component를 빠르게 찾기 위해(GetComponent) 사용합니다. type_index는 typeid를 해시 가능한 키로 만들어줍니다.
3. 생명주기 함수 연결
GameObject의 생명주기 함수가 호출될 때, GameObject는 자신이 가진 모든 활성 컴포넌트들의 해당 생명주기 함수를 순차적으로 호출해줍니다.

GameObject.cpp
#include "GameObject.h"
#include "Transform.h" // Transform 컴포넌트 구현 후 포함

GameObject::GameObject() {
    // GameObject 생성 시 Transform 컴포넌트는 필수로 추가
    transform = AddComponent<Transform>();
}

GameObject::~GameObject() {
    m_components.clear();
    m_activeComponents.clear();
}

void GameObject::Start() {
    for (auto* comp : m_activeComponents) {
        if (comp->IsEnabled()) {
            comp->Start();
        }
    }
}

void GameObject::Update(float dt) {
    if (!active) return;
    for (auto* comp : m_activeComponents) {
        if (comp->IsEnabled()) {
            comp->Update(dt);
        }
    }
}

void GameObject::Render(HDC hdc) {
    if (!active) return;
    for (auto* comp : m_activeComponents) {
        if (comp->IsEnabled()) {
            comp->Render(hdc);
        }
    }
}
AI에게 할 수 있는 질문
개념 이해
"상속 대신 컴포넌트 패턴을 사용했을 때의 장점을 '유연성'과 '재사용성' 측면에서 구체적인 게임 예시를 들어 설명해 줘. (예: '날아다니는 불 뿜는 거북이' 캐릭터 만들기)"
"GameObject가 Component를 관리할 때 std::unique_ptr를 사용하는 이유는 무엇이며, 만약 일반 포인터(Component*)를 사용했다면 어떤 메모리 관리 문제가 발생할 수 있는지 알려줘."
"GetComponent에서 typeid를 사용하는 원리는 무엇이며, 왜 이 방식이 특정 타입의 컴포넌트를 빠르게 찾을 수 있게 해주는지 설명해 줘."
기능 구현 및 결과 도출
"캐릭터의 체력(HP)과 공격력(ATK)을 관리하는 StatComponent를 만들어보고 싶어. Component를 상속받고 int m_hp, int m_atk 멤버를 가지는 StatComponent의 전체 코드를 작성해 줘."
"GameObject에 StatComponent를 추가하고, GetComponent로 찾아서 m_hp 값을 10 감소시키는 코드를 보여줘. 만약 StatComponent가 없다면 어떻게 되는지도 알려줘."
"GameObject에 '태그(Tag)' 기능을 추가하고 싶어. GameObject에 std::string m_tag; 멤버를 추가하고, Scene에서 FindObjectByTag(const std::string& tag) 함수를 통해 특정 태그를 가진 GameObject를 찾는 기능을 어떻게 구현해야 할지 설명해 줘."
"현재 GetComponent<T>는 정확한 T 타입만 찾을 수 있는데, T를 상속받는 자식 클래스 타입의 컴포넌트까지 모두 찾을 수 있도록 GetComponentsInChildren<T>()와 같은 함수를 구현하고 싶어. dynamic_cast를 활용하여 m_components 맵을 순회하면서 타입 변환을 시도하는 방식으로 코드를 작성해 줘."