FrameWork_2DAPI 문서 1: 프로젝트 설정 및 윈도우 생성
2D 게임 프레임워크 개발의 첫걸음은 게임이 실행될 창(Window)을 만들고, 그 안에서 지속적으로 게임 로직을 업데이트하고 화면을 그릴 수 있는 기반을 마련하는 것입니다. 이 문서에서는 Visual Studio에서 WinAPI 프로젝트를 설정하고, 기본적인 윈도우 창을 생성하며, 게임의 심장 역할을 하는 메인 게임 루프(Game Loop)를 구성하는 방법을 안내합니다.

1. Visual Studio 프로젝트 설정
새 프로젝트 생성: Visual Studio를 열고 '새 프로젝트 만들기'를 선택합니다.
프로젝트 템플릿 선택: 'Windows 데스크톱 마법사' 또는 'Windows 데스크톱 응용 프로그램' 템플릿을 검색하여 선택합니다.
프로젝트 구성: 프로젝트 이름(예: FrameWork_2DAPI)을 지정하고 솔루션을 만듭니다.
애플리케이션 설정: 마법사가 나타나면 '애플리케이션 종류'를 '데스크톱 애플리케이션(.exe)'으로, '추가 옵션'에서 '빈 프로젝트'를 선택합니다. 이렇게 하면 불필요한 파일 없이 처음부터 프로젝트를 구성할 수 있습니다.
소스 파일 추가: '소스 파일' 필터에 새로운 C++ 파일(예: FrameWork_2DAPI.cpp)을 추가하여 코드를 작성할 준비를 합니다.
2. WinMain: 애플리케이션의 시작점
모든 WinAPI 애플리케이션은 main 함수 대신 wWinMain (유니코드) 또는 WinMain (ANSI) 함수에서 시작됩니다. 이 함수는 운영체제로부터 프로그램의 인스턴스 핸들, 이전 인스턴스 핸들, 명령줄 인수, 창 표시 상태 등의 정보를 받습니다.

wWinMain 함수의 주요 역할은 다음과 같습니다.

윈도우 클래스 등록 (MyRegisterClass)
윈도우 생성 및 표시 (InitInstance)
메인 게임 루프 실행
// FrameWork_2DAPI.cpp
int APIENTRY wWinMain(_In_ HINSTANCE hInstance, ...)
{
    // 1. 윈도우 클래스의 특성(모양, 동작 등)을 정의하고 운영체제에 등록합니다.
    MyRegisterClass(hInstance);

    // 2. 등록된 클래스를 기반으로 실제 윈도우를 생성하고 화면에 표시합니다.
    if (!InitInstance (hInstance, nCmdShow))
    {
        return FALSE;
    }
    
    // ... (BaseGame 초기화) ...

    // 3. 게임 루프를 시작합니다.
    while (g_isRunning) {
        // ... (게임 루프 로직) ...
    }

    return (int) msg.wParam;
}
3. 윈도우 클래스 등록과 생성
MyRegisterClass
윈도우를 생성하기 전에 어떤 종류의 윈도우를 만들 것인지 그 '설계도'를 운영체제에 등록해야 합니다. WNDCLASSEXW 구조체에 창의 배경색, 커서 모양, 아이콘, 그리고 가장 중요한 윈도우 프로시저(Window Procedure) 함수 포인터(lpfnWndProc) 등을 설정합니다.

InitInstance
MyRegisterClass를 통해 등록된 '설계도'의 이름을 사용하여 CreateWindowW 함수로 실제 윈도우를 생성합니다. 생성된 윈도우의 핸들(HWND)은 이후 윈도우를 제어하는 데 사용되므로 전역 변수(예: g_hWnd)에 저장해 두는 것이 일반적입니다.

4. WndProc: 메시지 처리기
윈도우 프로시저(WndProc)는 운영체제로부터 발생하는 모든 메시지를 수신하는 함수입니다. 키보드 입력(WM_KEYDOWN), 마우스 클릭(WM_LBUTTONDOWN), 창 크기 변경(WM_SIZE), 그리고 화면을 다시 그려야 할 때(WM_PAINT) 등 모든 이벤트가 메시지 형태로 이 함수에 전달됩니다.

// FrameWork_2DAPI.cpp
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    // InputManager가 메시지를 먼저 처리하도록 전달 (3장에서 구현)
    // g_BaseGame.UpdateInput(message, wParam, lParam);

    switch (message)
    {
    case WM_PAINT:
        {
            // 화면을 그리는 로직 호출
            // ...
        }
        break;
    case WM_DESTROY:
        // 창이 닫힐 때 WM_QUIT 메시지를 보내 게임 루프를 종료시킴
        PostQuitMessage(0);
        break;
    default:
        // 우리가 처리하지 않는 메시지는 기본 처리기에 넘김
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}
5. 메인 게임 루프
게임 루프는 게임이 실행되는 동안 무한히 반복되며, 매 반복마다 다음 세 가지 작업을 수행합니다.

입력 처리 (Process Input): 사용자 입력을 확인합니다.
로직 업데이트 (Update): 게임 상태를 갱신합니다. (캐릭터 이동, 충돌 확인 등)
렌더링 (Render): 변경된 게임 상태를 화면에 그립니다.
GetMessage를 사용하는 전통적인 메시지 루프는 메시지가 있을 때만 작동하므로 게임에 적합하지 않습니다. 대신, 메시지가 없어도 항상 실행되는 PeekMessage를 사용하여 게임 루프를 구성해야 합니다.

// wWinMain 함수 내부
MSG msg;
g_BaseGame.Init(g_hWnd); // 게임 객체 초기화

while (g_isRunning) {
    // 1. 메시지 큐에 메시지가 있는지 확인하고 처리합니다.
    if (PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE)) {
        if (msg.message == WM_QUIT) {
            g_isRunning = false;
        }
        // ... 메시지 번역 및 전달 ...
    }
    
    // 2. 메시지가 없을 때 게임 로직을 실행합니다.
    g_BaseGame.AllUpdate(); // 입력 처리, 로직 업데이트

    // 3. 화면을 갱신하도록 WM_PAINT 메시지를 요청합니다.
    InvalidateRect(g_hWnd, nullptr, FALSE);
}
InvalidateRect 함수는 윈도우의 전체 또는 일부를 무효화(invalid)하여 운영체제에게 해당 영역을 다시 그려야 함을 알립니다. 이로 인해 WndProc에 WM_PAINT 메시지가 발생하게 됩니다.

6. 더블 버퍼링으로 깜박임 없는 렌더링
WM_PAINT에서 화면에 직접 그림을 그리면, 그림이 그려지는 중간 과정이 사용자에게 노출되어 화면이 심하게 깜박이는 현상이 발생합니다. 이를 해결하기 위해 더블 버퍼링(Double Buffering) 기법을 사용합니다.

화면과 동일한 크기의 보이지 않는 메모리 공간(백 버퍼, Back Buffer)을 만듭니다.
모든 그리기 작업을 이 백 버퍼에 수행합니다.
모든 그리기가 완료되면, 백 버퍼의 내용을 화면(프론트 버퍼, Front Buffer)으로 한 번에 복사합니다.
// WndProc 함수의 WM_PAINT 처리 부분
case WM_PAINT:
    {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hWnd, &ps); // 화면 DC

        RECT clientRect;
        GetClientRect(hWnd, &clientRect);
        int width = clientRect.right;
        int height = clientRect.bottom;

        // 1. 백 버퍼 생성
        HDC memDC = CreateCompatibleDC(hdc);
        HBITMAP backBuffer = CreateCompatibleBitmap(hdc, width, height);
        HBITMAP oldBitmap = (HBITMAP)SelectObject(memDC, backBuffer);

        // 2. 모든 그리기를 백 버퍼(memDC)에 수행
        g_BaseGame.Render(memDC, clientRect);

        // 3. 백 버퍼의 내용을 화면으로 복사
        BitBlt(hdc, 0, 0, width, height, memDC, 0, 0, SRCCOPY);

        // 리소스 정리
        SelectObject(memDC, oldBitmap);
        DeleteObject(backBuffer);
        DeleteDC(memDC);

        EndPaint(hWnd, &ps);
    }
    break;
AI에게 할 수 있는 질문
개념 이해
"GetMessage와 PeekMessage의 가장 큰 차이점은 무엇이며, 왜 게임 루프에서는 PeekMessage를 사용해야만 하는지 설명해 줘."
"더블 버퍼링의 원리에 대해 설명하고, 만약 더블 버퍼링을 사용하지 않으면 어떤 시각적인 문제가 발생하는지 알려줘."
"WndProc는 CALLBACK으로 선언되는데, 이 키워드는 무엇을 의미하며 왜 이 함수는 정적(static)이거나 전역 함수여야 하는지 설명해 줘."
기능 구현 및 결과 도출
"Visual Studio 2022에서 'Windows 데스크톱 마법사'를 사용하여 빈 WinAPI 프로젝트를 만드는 과정을 단계별로 스크린샷과 함께 설명해 줘."
"창 크기를 조절할 수 없도록 고정하고, 창의 초기 크기를 800x600으로 설정하고 싶어. CreateWindowW 함수의 인자를 어떻게 수정해야 하는지 코드로 보여줘."
"게임 화면을 전체 화면(Fullscreen) 모드로 전환하는 기능을 구현하고 싶어. F11 키를 누르면 전체 화면 모드로 들어가고, 다시 누르면 창 모드로 돌아오도록 WndProc에 코드를 추가해 줘."
"현재 게임 루프는 가능한 가장 빠른 속도로 실행되는데, 초당 60프레임(60 FPS)으로 프레임 속도를 고정하고 싶어. chrono 라이브러리를 사용해서 프레임 시작과 끝의 시간을 측정하고, 목표 프레임 시간(약 16.6ms)보다 짧으면 Sleep을 호출하여 대기하는 로직을 게임 루프에 추가하는 코드를 작성해 줘."