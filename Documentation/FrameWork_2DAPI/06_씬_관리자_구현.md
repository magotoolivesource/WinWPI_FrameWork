FrameWork_2DAPI 문서 6: 씬 관리자 구현
게임은 '메인 메뉴', '1 스테이지', '게임 오버 화면' 등 여러 화면으로 구성됩니다. 이 각각의 독립적인 단위를 **씬(Scene)**이라고 합니다. Scene 클래스의 역할은 특정 씬에 존재하는 모든 GameObject들을 담고, 이들의 생명주기(Start, Update, Render)를 관리하는 것입니다.

이번 문서에서는 GameObject들을 효율적으로 관리하고 업데이트 및 렌더링을 총괄하는 Scene 클래스를 구현하는 방법을 알아봅니다.

1. Scene 클래스 기본 구조
Scene 클래스는 내부에 GameObject 목록을 가지고 있으며, 이 목록을 순회하며 각 GameObject의 Update와 Render를 호출해주는 역할을 합니다. GameObject의 소유권을 Scene이 가지도록 std::vector<std::unique_ptr<GameObject>>를 사용하는 것이 좋습니다.

Scene.h
#pragma once
#include <vector>
#include <memory>
#include <string>
#include <windows.h> // HDC 사용

#include "../Core/GameObject.h" // GameObject 사용

class Scene
{
protected:
    // 이 씬이 소유한 모든 GameObject 목록
    std::vector<std::unique_ptr<GameObject>> m_AllOjects;

public:
    Scene() = default;
    virtual ~Scene() = default;

    // --- 생명주기 함수 ---

    // 씬이 로드될 때 GameObject들을 생성하고 배치하는 함수
    virtual void InitSettings() {}

    // 매 프레임 모든 GameObject의 Update를 호출
    virtual void UpdateLoop(float dt);

    // 매 프레임 모든 GameObject의 Render를 호출
    virtual void Render(HDC p_hdc);

    // 씬이 종료될 때 모든 GameObject를 정리
    virtual void Release();

    // --- GameObject 관리 ---

    // 새로운 GameObject를 생성하여 씬에 추가
    GameObject* CreateObject(const std::string& name);

    // 특정 GameObject를 씬에서 제거하도록 예약
    virtual void DestroyObject(GameObject* obj);
};
2. GameObject 생명주기 관리
Scene의 UpdateLoop와 Render는 자신이 관리하는 모든 GameObject의 해당 함수들을 호출해주는 간단한 구조입니다.

Scene.cpp (기본 업데이트 및 렌더링)
#include "Scene.h"

void Scene::UpdateLoop(float dt)
{
    for (auto& obj : m_AllOjects) {
        obj->Update(dt);
    }
}

void Scene::Render(HDC p_hdc)
{
    for (auto& obj : m_AllOjects) {
        obj->Render(p_hdc);
    }
}

void Scene::Release()
{
    m_AllOjects.clear(); // unique_ptr이므로 clear() 시 자동으로 메모리 해제
}
3. 지연된 객체 관리 (Deferred Object Management)
만약 Update 루프 도중 GameObject가 다른 GameObject를 생성하거나 파괴한다면 어떻게 될까요? m_AllOjects 벡터를 순회하는 도중에 벡터의 내용이 변경되면, 반복자(iterator)가 무효화되어 프로그램이 충돌할 수 있습니다.

이를 방지하기 위해, GameObject의 생성과 파괴를 즉시 처리하지 않고 '대기열'에 등록했다가 안전한 시점(보통 다음 프레임 시작 전 또는 현재 프레임 끝난 후)에 일괄 처리하는 지연된 관리 방식을 사용합니다.

Scene.h (대기열 추가)
class Scene
{
    // ...
protected:
    // 생성 대기 중인 GameObject 목록
    std::vector<std::unique_ptr<GameObject>> m_pendingObjects;
    
    // 파괴 대기 중인 GameObject 목록
    std::vector<GameObject*> m_destroyQueue;
    
    // 새로 추가된 후 Start() 호출을 기다리는 GameObject 목록
    std::vector<GameObject*> m_pendingStartObjects;

protected:
    // 대기열을 처리하는 내부 함수
    void ProcessNewObjects();
    void ProcessDestroyQueue();
};
Scene.cpp (지연 관리 구현)
CreateObject는 이제 m_pendingObjects에 GameObject를 추가하고, DestroyObject는 m_destroyQueue에 추가합니다.

GameObject* Scene::CreateObject(const std::string& name)
{
    auto obj = std::make_unique<GameObject>(this); // 생성 시 Scene 자신을 넘겨줌
    obj->SetName(name);
    GameObject* ptr = obj.get();

    // 생성 대기열에 추가
    m_pendingObjects.emplace_back(std::move(obj));
    m_pendingStartObjects.push_back(ptr);

    return ptr;
}

void Scene::DestroyObject(GameObject* obj) {
    // 파괴 대기열에 추가 (중복 추가 방지)
    if (std::find(m_destroyQueue.begin(), m_destroyQueue.end(), obj) == m_destroyQueue.end()) {
        m_destroyQueue.push_back(obj);
    }
}
그리고 게임 루프의 특정 시점에 이 대기열들을 처리합니다.

// Scene.cpp
void Scene::UpdateLoop(float dt)
{
    // 1. 프레임 시작 시, 새로 생성된 객체들을 활성화하고 Start() 호출
    ProcessNewObjects();

    // 2. 모든 활성 객체들 업데이트
    for (auto& obj : m_AllOjects) {
        obj->Update(dt);
    }
}

void Scene::Render(HDC p_hdc)
{
    // 3. 모든 활성 객체들 렌더링
    for (auto& obj : m_AllOjects) {
        obj->Render(p_hdc);
    }
    
    // 4. 프레임 종료 시, 파괴 예약된 객체들을 실제로 제거
    ProcessDestroyQueue();
}

void Scene::ProcessNewObjects()
{
    if (m_pendingObjects.empty()) return;

    // 대기 중인 객체들을 실제 객체 리스트로 이동
    for (auto& obj : m_pendingObjects) {
        m_AllOjects.emplace_back(std::move(obj));
    }
    m_pendingObjects.clear();
    
    // 새로 추가된 객체들의 Start() 함수 호출
    for (auto* obj : m_pendingStartObjects) {
        obj->Start();
    }
    m_pendingStartObjects.clear();
}

void Scene::ProcessDestroyQueue()
{
    if (m_destroyQueue.empty()) return;

    for (auto* obj : m_destroyQueue) {
        // m_AllOjects에서 unique_ptr를 찾아 제거 (메모리 자동 해제)
        m_AllOjects.erase(
            std::remove_if(m_AllOjects.begin(), m_AllOjects.end(),
                           [obj](const auto& p) { return p.get() == obj; }),
            m_AllOjects.end()
        );
    }
    m_destroyQueue.clear();
}
AI에게 할 수 있는 질문
개념 이해
"게임 루프 중에 GameObject를 즉시 생성하거나 삭제하면 왜 프로그램이 충돌할 수 있는지, '반복자 무효화(iterator invalidation)' 개념과 관련하여 설명해 줘."
"Scene이 GameObject의 소유권을 std::unique_ptr로 관리하는 것의 장점은 무엇이며, std::shared_ptr를 사용했을 때와 비교해서 어떤 차이가 있을까?"
"현재 프레임워크에는 SceneManager가 없는데, 만약 여러 Scene(예: TitleScene, GameScene)을 관리하고 전환하는 SceneManager 클래스를 만든다면 어떤 기능과 멤버 변수가 필요할지 설계해 봐."
기능 구현 및 결과 도출
"게임이 끝났을 때 보여줄 'GameOverScene'을 직접 만들어보고 싶어. Scene을 상속받고, 화면 중앙에 'Game Over'라는 텍스트를 표시하는 InitSettings 메서드를 가진 GameOverScene 클래스의 전체 코드를 작성해 줘."
"현재 Scene에 있는 모든 'Enemy' 태그를 가진 GameObject를 찾아서 리스트로 반환하는 FindObjectsByTag(const std::string& tag) 함수를 Scene 클래스에 추가하고 싶어. m_AllOjects를 순회하면서 어떻게 구현해야 하는지 코드를 보여줘."
"게임 플레이 Scene에서 일시정지 메뉴를 띄우고 싶어. '일시정지' Scene을 따로 만들지 않고, 현재 Scene 위에 UI GameObject들을 동적으로 생성했다가 제거하는 방식으로 구현하고 싶어. 일시정지 버튼을 눌렀을 때 UI를 생성하고 게임 시간을 멈추는(TimeScale = 0) 코드와, '계속하기' 버튼을 눌렀을 때 UI를 제거하고 게임 시간을 원래대로 되돌리는 코드를 작성해 줘."
"현재 Scene에 있는 GameObject를 다른 Scene으로 이동시키는 기능을 구현하고 싶어. GameObject를 현재 Scene의 관리 목록에서 제거하고 다음 Scene의 '대기' 목록으로 넘겨주는 MoveObjectToScene(GameObject* obj, Scene* newScene) 함수의 아이디어와 구현 방법을 설명해 줘. (Unity의 DontDestroyOnLoad와 유사한 기능)"