FrameWork_2DAPI 문서 5: 트랜스폼 컴포넌트 구현
모든 GameObject는 게임 세계 어디엔가에 '존재'해야 합니다. 그 존재의 기반이 되는 위치(Position), 회전(Rotation), 크기(Scale) 정보를 관리하는 것이 바로 Transform 컴포넌트의 역할입니다. Transform은 모든 GameObject가 반드시 가져야 하는 가장 기본적인 컴포넌트입니다.

또한, Transform은 부모-자식 관계를 통해 GameObject들을 계층적으로 구성(Scene Graph)하는 핵심 기능을 제공합니다.

1. Transform 기본 구조 설계
Transform 컴포넌트는 Component를 상속받으며, 자신의 지역(Local) 공간에서의 위치, 회전, 크기 값을 저장합니다.

localPosition: 부모 Transform을 기준으로 한 상대적인 위치. 부모가 없다면 월드 공간의 위치와 같습니다.
localRotation: 부모 Transform을 기준으로 한 상대적인 회전 각도.
localScale: 부모 Transform을 기준으로 한 상대적인 크기 배율.
Transform.h (기본 구조)
#pragma once
#include "Component.h"
#include "../Core/Vector.h" // Vec2 사용

class Transform : public Component
{
protected:
    Vec2 m_localPosition = { 0.0f, 0.0f };
    float m_localRotation = 0.0f;
    Vec2 m_localScale = { 1.0f, 1.0f };

public:
    Transform() = default;
    virtual ~Transform() = default;

    // --- Local 값 접근자 ---
    void setLocalPosition(const Vec2& pos) { m_localPosition = pos; }
    Vec2 getLocalPosition() const { return m_localPosition; }

    // ... Rotation, Scale에 대한 Getter/Setter ...
};
2. 부모-자식 관계 구현
Transform이 다른 Transform의 자식이 되면, 자식의 모든 변환(이동, 회전, 크기 조절)은 부모의 변환에 상대적으로 적용됩니다. 예를 들어, 부모가 오른쪽으로 10만큼 이동하면 모든 자식들도 따라서 오른쪽으로 10만큼 이동합니다.

이를 위해 Transform 클래스에 부모와 자식 목록을 관리할 포인터를 추가합니다.

Transform.h (계층 구조 추가)
#include <vector>
#include <algorithm> // std::find

class Transform : public Component
{
    // ... 기존 멤버 ...

protected:
    Transform* m_parent = nullptr;
    std::vector<Transform*> m_children;

public:
    // --- 계층 구조 관리 ---
    void SetParent(Transform* p_parent);
    Transform* GetParent() const { return m_parent; }
    const std::vector<Transform*>& GetChildren() const { return m_children; }

private:
    void AddChild(Transform* p_child);
    void RemoveChild(Transform* p_child);
};
Transform.cpp (계층 구조 구현)
SetParent 함수는 기존 부모와의 관계를 끊고 새로운 부모와 관계를 맺는 중요한 로직을 담당합니다.

void Transform::SetParent(Transform* p_parent)
{
    // 기존 부모가 있었다면, 기존 부모의 자식 목록에서 나를 제거
    if (m_parent != nullptr) {
        m_parent->RemoveChild(this);
    }

    // 새로운 부모 설정
    m_parent = p_parent;

    // 새로운 부모가 있다면, 새로운 부모의 자식 목록에 나를 추가
    if (m_parent != nullptr) {
        m_parent->AddChild(this);
    }
}

void Transform::AddChild(Transform* p_child)
{
    m_children.push_back(p_child);
}

void Transform::RemoveChild(Transform* p_child)
{
    auto it = std::find(m_children.begin(), m_children.end(), p_child);
    if (it != m_children.end()) {
        m_children.erase(it);
    }
}
3. 월드 변환 행렬과 isDirty 플래그
렌더링이나 물리 계산에는 각 GameObject의 최종적인 월드 공간(World Space)에서의 위치, 회전, 크기가 필요합니다. 이는 자신의 local 변환과 모든 조상의 world 변환을 곱해서 계산할 수 있습니다.

World Transform = Parent's World Transform * Local Transform

이 계산은 비용이 크므로, 매 프레임 계산하는 대신 Transform의 값이 변경되었을 때만 계산하는 것이 효율적입니다. isDirty 플래그는 이 '값이 변경되었음'을 알리는 역할을 합니다.

local 위치, 회전, 크기가 변경되면, 자신과 자신의 모든 자식들의 isDirty 플래그를 true로 설정합니다.
월드 변환 행렬을 요청(GetWorldMatrix)할 때, isDirty가 true이면 행렬을 다시 계산하고 캐싱한 뒤, isDirty를 false로 되돌립니다. false라면 캐싱된 행렬을 즉시 반환합니다.
Transform.h (isDirty 및 행렬 추가)
#include <gdiplus.h> // Gdiplus::Matrix 사용

class Transform : public Component
{
    // ... 기존 멤버 ...
protected:
    bool m_isDirty = true;
    Gdiplus::Matrix m_worldMatrix; // 계산된 월드 변환 행렬을 캐싱

public:
    // ...
    void setLocalPosition(const Vec2& pos) { m_localPosition = pos; SetDirty(); }
    
    void SetDirty();
    Gdiplus::Matrix& GetWorldMatrix();
};
Transform.cpp (행렬 계산 구현)
void Transform::SetDirty()
{
    if (!m_isDirty) {
        m_isDirty = true;
        // 나의 모든 자식들도 dirty 상태로 만듦
        for (Transform* child : m_children) {
            child->SetDirty();
        }
    }
}

Gdiplus::Matrix& Transform::GetWorldMatrix()
{
    if (m_isDirty) {
        // 1. 자신의 Local 변환 행렬을 계산 (크기 -> 회전 -> 이동 순서)
        Gdiplus::Matrix localMatrix;
        localMatrix.Translate(m_localPosition.x, m_localPosition.y);
        localMatrix.Rotate(m_localRotation);
        localMatrix.Scale(m_localScale.x, m_localScale.y);

        if (m_parent) {
            // 2. 부모가 있다면, 부모의 월드 행렬을 가져와 곱함
            m_worldMatrix = localMatrix;
            m_worldMatrix.Multiply(&m_parent->GetWorldMatrix(), Gdiplus::MatrixOrderAppend);
        } else {
            // 3. 부모가 없다면, 나의 로컬 행렬이 곧 월드 행렬
            m_worldMatrix = localMatrix;
        }
        
        m_isDirty = false; // 계산이 끝났으므로 dirty 플래그를 해제
    }
    
    return m_worldMatrix;
}
AI에게 할 수 있는 질문
개념 이해
"부모 GameObject를 회전시킬 때 자식 GameObject가 부모를 중심으로 공전하는 것처럼 보이는 원리를 Local Matrix와 World Matrix의 곱셈 과정으로 설명해 줘."
"isDirty 플래그가 왜 필요한지 성능 최적화 관점에서 설명해 줘. 만약 이 플래그 없이 매번 GetWorldMatrix를 호출할 때마다 행렬을 계산한다면, 자식 오브젝트가 많은 복잡한 씬에서 어떤 문제가 발생할까?"
"변환 행렬을 계산할 때 왜 일반적으로 '크기(Scale) -> 회전(Rotate) -> 이동(Translate)' 순서로 연산을 적용하는지, 만약 순서를 바꾸면(예: 이동 -> 회전) 어떤 의도치 않은 결과가 나타나는지 그림으로 설명해 줘."
기능 구현 및 결과 도출
"월드 행렬(m_worldMatrix)로부터 월드 위치(WorldPosition) 값을 추출하는 Vec2 GetWorldPosition() const 함수를 Transform 클래스에 추가하고 싶어. Gdiplus::Matrix의 GetElements를 사용해서 어떻게 구현해야 하는지 코드를 보여줘."
"특정 GameObject가 다른 GameObject를 계속해서 바라보게 만드는 LookAt(const Vec2& targetPosition) 함수를 Transform에 추가하고 싶어. atan2 함수를 사용해서 목표 지점까지의 각도를 계산하고, m_localRotation을 설정하는 코드를 작성해 줘."
"SetParent(Transform* p_parent) 함수에 bool worldPositionStays = true라는 두 번째 인자를 추가하고 싶어. 이 값이 true일 때, 부모를 변경하더라도 GameObject의 월드 위치는 그대로 유지되도록 m_localPosition 값을 역산하여 설정하는 코드를 구현해 줘."
"현재 Transform의 모든 자식 GameObject를 재귀적으로 순회하면서 특정 함수(예: 람다 함수)를 호출하는 TraverseChildren(const std::function<void(Transform*)>& visitor) 함수를 구현하는 코드를 보여줘."