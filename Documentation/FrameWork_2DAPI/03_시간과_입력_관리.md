FrameWork_2DAPI 문서 3: 시간과 입력 관리
모든 인터랙티브 애플리케이션의 핵심은 사용자의 입력에 반응하고, 일관된 속도로 업데이트되는 것입니다. 이번 문서에서는 게임의 '시간'을 관리하여 프레임 속도에 독립적인 움직임을 구현하는 TimerManager와, 키보드 및 마우스 입력을 처리하는 InputManager를 구현하는 방법을 알아봅니다.

1. 시간 관리자 (TimerManager) 구현
컴퓨터의 성능에 따라 게임의 초당 프레임 수(FPS)는 계속 변동합니다. 만약 "매 프레임마다 1픽셀씩 이동"과 같이 로직을 작성하면, 고성능 컴퓨터에서는 캐릭터가 매우 빠르게, 저성능 컴퓨터에서는 느리게 움직이는 문제가 발생합니다.

이를 해결하기 위해 델타 타임(Delta Time) 개념을 사용합니다. 델타 타임은 이전 프레임이 완료되는 데 걸린 시간(초)으로, 모든 움직임 계산에 이 값을 곱해주면 컴퓨터 성능과 관계없이 항상 일관된 속도를 유지할 수 있습니다.

TimerManager는 Windows의 고정밀 타이머 함수인 QueryPerformanceCounter를 사용하여 델타 타임을 정밀하게 측정합니다.

TimerManager.h
#pragma once
#include <windows.h>

class TimerManager {
private:
    LARGE_INTEGER frequency;    // 타이머의 주파수 (초당 틱 수)
    LARGE_INTEGER lastTime;     // 이전 프레임의 시간
    double deltaTime;           // 계산된 델타 타임

public:
    TimerManager() {
        QueryPerformanceFrequency(&frequency); // 시스템의 타이머 주파수 획득
        QueryPerformanceCounter(&lastTime);    // 현재 시간으로 초기화
        deltaTime = 0;
    }

    // 매 프레임 게임 루프 시작 시 호출
    void Update() {
        LARGE_INTEGER currentTime;
        QueryPerformanceCounter(&currentTime);

        // 현재 시간과 이전 시간의 차이를 주파수로 나누어 초 단위 델타 타임 계산
        deltaTime = static_cast<double>(currentTime.QuadPart - lastTime.QuadPart) / frequency.QuadPart;
        
        // 다음 프레임을 위해 현재 시간을 lastTime에 저장
        lastTime = currentTime;
    }

    // 계산된 델타 타임 반환
    double GetDeltaTime() const {
        return deltaTime;
    }

    // 현재 FPS 계산 (디버깅용)
    float GetFPS() const {
        if (deltaTime > 0) {
            return 1.0f / static_cast<float>(deltaTime);
        }
        return 0.0f;
    }
};
BaseGame 클래스에 통합
BaseGame 클래스(또는 메인 게임 클래스)가 TimerManager 인스턴스를 소유하고, 매 프레임 Update를 호출하여 델타 타임을 갱신합니다.

// BaseGame.h
class TimerManager; // 전방 선언

class BaseGame {
    // ...
private:
    TimerManager* m_pTimerManager = nullptr;
};

// BaseGame.cpp
void BaseGame::Init(HWND p_hwnd) {
    // ...
    m_pTimerManager = new TimerManager();
}

void BaseGame::AllUpdate() {
    m_pTimerManager->Update(); // 매 프레임 델타 타임 갱신
    
    float dt = m_pTimerManager->GetDeltaTime();
    
    // ...
    m_CurrentScene->UpdateLoop(dt); // Scene과 모든 GameObject에 dt 전달
    // ...
}
2. 입력 관리자 (InputManager) 구현
InputManager는 WndProc을 통해 전달되는 키보드, 마우스 메시지(WM_KEYDOWN, WM_LBUTTONDOWN 등)를 받아 내부 상태 배열에 저장하고, 게임의 어느 곳에서든 쉽게 입력 상태를 확인할 수 있는 정적(static) 함수들을 제공합니다.

InputManager는 세 가지 종류의 입력 상태를 구분하여 처리합니다.

Down: 키가 '방금 눌린' 프레임. (단발성 액션)
Pressed: 키가 '눌리고 있는' 동안. (지속적인 액션)
Up: 키가 '방금 떼어진' 프레임. (액션 종료)
InputManager.h
#pragma once
#include <windows.h>
#include <cstring> // memset 사용

// 키 코드를 쉽게 사용하기 위한 열거형 (WinAPI 가상 키 코드 사용)
enum class InputKey : int {
    LeftMouse = VK_LBUTTON,
    Space = VK_SPACE,
    LeftArrow = VK_LEFT,
    A = 'A', W = 'W', S = 'S', D = 'D',
    // ... 필요한 키 추가
};

class InputManager {
public:
    // 각 키의 상태를 저장하는 배열
    static bool keys[256];      // Key Pressed (누르고 있음)
    static bool iskeys_down[256]; // Key Down (방금 눌림)
    static bool iskeys_up[256];   // Key Up (방금 떼어짐)
    static POINT mousePosition;

public:
    // 게임 루프 시작 시 호출되어 Down/Up 상태를 초기화
    static void ResetAllKey() { 
        memset(iskeys_down, false, sizeof(iskeys_down));
        memset(iskeys_up, false, sizeof(iskeys_up));
    }

    // WndProc에서 WM_KEYDOWN 메시지 수신 시 호출
    static void KeyDown(WPARAM key) {
        if (key < 256) {
            keys[key] = true;
            iskeys_down[key] = true;
        }
    }

    // WndProc에서 WM_KEYUP 메시지 수신 시 호출
    static void KeyUp(WPARAM key) {
        if (key < 256) {
            keys[key] = false;
            iskeys_up[key] = true;
        }
    }
    
    // 외부에서 키 상태를 확인하는 함수들
    static bool ISKeyDown(InputKey key) { return iskeys_down[(int)key]; }
    static bool IsKeyPressed(InputKey key) { return keys[(int)key]; }
    static bool ISKeyUp(InputKey key) { return iskeys_up[(int)key]; }
    
    // ... 마우스 관련 함수들 (MouseMove, MouseDown, MouseUp) ...
};
주의: InputManager의 정적 멤버 변수들은 .cpp 파일에서 초기화해주어야 합니다. (예: bool InputManager::keys[256] = {false};)

WndProc 및 게임 루프에 통합
WndProc에서 수신한 입력 메시지를 InputManager의 정적 함수에 전달하고, 게임 루프가 시작될 때마다 ResetAllKey를 호출하여 상태를 초기화합니다.

// FrameWork_2DAPI.cpp

// WndProc
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    // g_BaseGame을 통해 InputManager에 메시지 전달
    g_BaseGame.UpdateInput(message, wParam, lParam);
    // ...
}

// BaseGame.cpp
void BaseGame::UpdateInput(UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message) {
    case WM_KEYDOWN:
        InputManager::KeyDown(wParam);
        break;
    case WM_KEYUP:
        InputManager::KeyUp(wParam);
        break;
    // ... 마우스 메시지 처리 ...
    }
}

void BaseGame::AllUpdate() 
{ 
    // ...
    // 중요: 입력 상태 갱신 전에 Reset을 호출해야 함
    InputManager::ResetAllKey();
    // ...
}
AI에게 할 수 있는 질문
개념 이해
"TimerManager에서 QueryPerformanceFrequency와 QueryPerformanceCounter 함수가 어떻게 고정밀 시간을 측정하는지 원리를 설명해 줘."
"InputManager에서 iskeys_down과 iskeys_up 배열을 매 프레임 ResetAllKey로 초기화하는 이유는 무엇이며, 만약 이 함수를 호출하지 않으면 ISKeyDown 함수가 어떻게 동작하게 될까?"
"정적(static) 클래스로 InputManager를 구현했을 때의 장점은 무엇이며, 싱글턴(Singleton) 패턴과 비교했을 때 어떤 차이점이 있는지 알려줘."
기능 구현 및 결과 도출
"플레이어가 점프하는 기능을 구현하고 싶어. PlayerController 컴포넌트의 Update 메서드에서, 스페이스바를 '방금 눌렀을 때'(ISKeyDown) 플레이어의 y축 속도(velocity.y)를 위쪽으로 설정하는 코드를 작성해 줘."
"마우스 휠 스크롤 입력을 처리하고 싶어. WndProc에서 WM_MOUSEWHEEL 메시지를 어떻게 처리하고, 휠이 위 또는 아래로 스크롤되었는지 판단하여 InputManager에 전달하는 코드를 보여줘."
"키보드뿐만 아니라 게임패드(조이패드) 입력을 지원하도록 InputManager를 확장하려면 어떻게 해야 할까? XInput 라이브러리를 사용한다고 가정하고, 컨트롤러의 연결 상태를 확인하고 아날로그 스틱의 입력을 읽어오는 함수를 추가하는 방법을 설명해 줘."
"사용자가 키 설정을 변경할 수 있는 '키 바인딩(Key Binding)' 기능을 구현하고 싶어. std::map<std::string, InputKey> 같은 자료구조를 사용해서 "JUMP", "ATTACK"과 같은 행동 이름에 실제 키를 매핑하고, InputManager가 이 맵을 참조하여 키 입력을 확인하도록 수정하는 아이디어를 제시해 줘."