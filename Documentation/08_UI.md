# 8. UI 시스템: 게임과 플레이어의 상호작용

## 소개

UI(User Interface) 시스템은 플레이어가 게임과 상호작용할 수 있는 시각적인 요소들을 제공합니다. 이 프레임워크는 컴포넌트 기반으로 UI를 구축하며, `Button`과 `TextComponent`가 가장 기본적인 UI 요소입니다. 모든 UI 컴포넌트는 다른 컴포넌트와 마찬가지로 `GameObject`에 부착되어 작동합니다.

- **`Button`:** 플레이어의 마우스 클릭에 반응하는 상호작용 가능한 영역입니다.
- **`TextComponent`:** 화면에 텍스트를 표시합니다.
- **`RichTextComponent`:** `<color>`와 같은 태그를 사용하여 텍스트의 일부에 다른 스타일을 적용할 수 있는 고급 텍스트 컴포넌트입니다.

## 핵심 개념

### 이벤트 기반 상호작용

UI 시스템, 특히 `Button`은 이벤트 기반으로 작동합니다. `Button` 컴포넌트는 마우스 클릭 이벤트를 감지하고, 이 이벤트가 발생했을 때 미리 등록된 콜백 함수(Callback Function)를 실행합니다. 이를 통해 "버튼이 클릭되면 게임을 시작한다" 또는 "아이템을 구매한다"와 같은 로직을 쉽게 구현할 수 있습니다.

### 좌표계와 UI

UI 요소는 종종 게임 세계의 특정 위치가 아닌, 화면의 고정된 위치에 표시되어야 합니다. 예를 들어, 플레이어의 체력 바는 항상 화면 왼쪽 상단에 있어야 합니다.

이를 구현하는 방법에는 두 가지가 있습니다.

1.  **스크린 공간 UI:** 카메라의 움직임에 영향을 받지 않는 UI입니다. `TextComponent`의 `SetIsCameraMatrix(false)`를 호출하면 카메라 변환이 적용되지 않아 항상 같은 화면 위치에 텍스트가 렌더링됩니다.
2.  **월드 공간 UI:** 게임 세계의 일부처럼 카메라의 움직임에 따라 함께 움직이는 UI입니다. 예를 들어, 캐릭터의 머리 위에 표시되는 이름표가 여기에 해당합니다. `TextComponent`는 기본적으로 월드 공간 UI로 작동합니다.

## UI 컴포넌트 사용법

### `Button` 사용하기

`Button` 컴포넌트를 `GameObject`에 추가하고, 생성자나 `OnClickCallBack` 메서드를 통해 클릭 시 실행될 람다 함수나 일반 함수를 등록할 수 있습니다.

```cpp
// MainMenuScene.cpp
#include "Core/GameObject.h"
#include "UICompoment/Button.h"

void MainMenuScene::InitSettings()
{
    // "StartButton" GameObject 생성
    GameObject* startButtonObj = CreateObject("StartButton");
    startButtonObj->transform->setLocalPosition(350, 250); // 화면 위치 설정

    // Button 컴포넌트 추가 및 클릭 이벤트 핸들러 등록
    auto* button = startButtonObj->AddComponent<Button>([](Button* sender) {
        // 이 코드는 버튼이 클릭될 때 실행됩니다.
        // 예를 들어, 게임 씬으로 전환하는 로직을 여기에 작성합니다.
        // Game::GetInstance()->ChangeScene(new GameScene());
        MessageBox(nullptr, L"Start 버튼 클릭됨!", L"알림", MB_OK);
    });

    // 버튼의 크기 설정
    button->SetBTNSize(100, 50);
}
```

### `TextComponent` 사용하기

`TextComponent`를 사용하여 화면에 텍스트를 표시할 수 있습니다. 다양한 메서드를 통해 텍스트의 스타일을 변경할 수 있습니다.

```cpp
// HUD.cpp
#include "Core/GameObject.h"
#include "UICompoment/TextComponent.h"

void CreateHUD()
{
    // 점수 표시를 위한 GameObject 생성
    GameObject* scoreTextObj = new GameObject(this);
    scoreTextObj->SetName("ScoreText");

    auto* text = scoreTextObj->AddComponent<TextComponent>();

    // 텍스트 내용 및 스타일 설정
    text->SetText(L"Score: 0");
    text->SetFont(L"Arial", 24.0f);
    text->SetFontColor(255, 255, 255, 255); // 흰색
    text->SetSize(200, 50); // 텍스트가 표시될 영역 크기

    // 위치 설정 (카메라 영향을 받지 않는 스크린 공간)
    text->SetIsCameraMatrix(false); // 중요!
    scoreTextObj->transform->setLocalPosition(10, 10); // 화면 왼쪽 상단
}
```

### 버튼과 텍스트 조합하기

버튼 위에 텍스트를 표시하려면, `Button` `GameObject`의 자식으로 `TextComponent`를 가진 `GameObject`를 만들면 됩니다.

```cpp
// 버튼 생성
GameObject* buttonObj = CreateObject("StyledButton");
buttonObj->transform->setLocalPosition(350, 350);
auto* button = buttonObj->AddComponent<Button>();
button->SetBTNSize(120, 40);

// 버튼 위에 표시될 텍스트 생성
GameObject* textObj = CreateObject("ButtonText");
// 부모-자식 관계 설정
textObj->transform->SetParent(buttonObj->transform);

auto* text = textObj->AddComponent<TextComponent>();
text->SetText(L"Click Me!");
text->SetFont(L"Verdana", 18.0f);
text->SetSize(120, 40);
// 텍스트를 버튼 중앙에 정렬
text->SetAlignment(Gdiplus::StringAlignmentCenter, Gdiplus::StringAlignmentCenter);
```

## AI에게 할 수 있는 질문

### 개념 이해
- "`Button::ISClick()` 함수가 `transform`의 월드 행렬에 역행렬(`Invert`)을 취해서 마우스 좌표를 로컬 좌표로 변환하는 원리에 대해 설명해 줘. 이 방식이 `GameObject`가 이동, 회전, 크기 조절되었을 때도 정확한 클릭 판정을 가능하게 하는 이유는 뭐야?"
- "월드 공간 UI와 스크린 공간 UI의 구체적인 예를 각각 들어주고, `TextComponent`의 `m_ISCameraMatrix` 플래그가 `Render` 함수에서 GDI+의 변환 행렬에 어떻게 영향을 미치는지 설명해 줘."
- "`Button::onClick` 멤버를 `std::function`으로 선언하면 왜 람다 함수, 멤버 함수 포인터(`std::bind`), 일반 함수 포인터 등 다양한 형태의 콜백을 등록할 수 있는지 설명해 줘. 만약 C 스타일의 함수 포인터 `void (*onClick)()`를 사용했다면 어떤 제약이 있을까?"
- "`RichTextComponent`가 `<color>` 태그를 파싱(parsing)해서 텍스트의 일부만 다른 색으로 그리는 기능을 구현하려면 어떤 로직이 필요할지 단계별로 설명해 줘. (문자열 분석, GDI+의 `MeasureString`, `DrawString` 활용 등)"

### 기능 구현 및 결과 도출
- "마우스를 올리면(`Hover`) 크기가 1.1배 커지고, 클릭하면(`Press`) 0.9배로 작아지는 시각적 피드백이 있는 버튼을 만들고 싶어. `Button` 컴포넌트를 상속받는 `AnimatedButton` 클래스를 만들고, `Update` 메서드에서 `isHovered`, `isPressed` 상태에 따라 `owner->transform`의 로컬 스케일을 조절하는 코드를 작성해 줘."
- "게임 점수가 올라갈 때마다 화면에 "+10"과 같은 텍스트가 나타났다가 1초 동안 위로 떠오르며 사라지는 '데미지 폰트' 효과를 구현하고 싶어. `TextComponent`를 가진 `GameObject`를 생성하고, `UtilTimerManager`를 사용하여 1초 동안 위치와 투명도(alpha)를 변경한 뒤 `GameObject`를 파괴하는 전체 과정을 코드로 보여줘."
- "드래그 앤 드롭(Drag and Drop)으로 식물을 심는 기능을 구현하고 싶어. `UI_SelectBTNCom`을 마우스 왼쪽 버튼으로 누른 채(`IsMouseLeftDown`) 드래그하면 식물 아이콘이 마우스를 따라다니다가, 버튼을 놓았을 때(`ISMouseUp`) 유효한 위치라면 식물을 생성하는 로직을 `UI_SelectBTNCom`의 `Update` 메서드에 어떻게 구현해야 하는지 코드로 보여줘."
- "체력 바(Health Bar) UI를 만들고 싶어. `ImageComponent` 두 개(배경, 전경)를 가진 `HealthBar` 컴포넌트를 만들고, `SetHealth(float current, float max)`라는 메서드를 호출하면 전경 이미지의 `drawWidth`를 비율에 맞게 조절하여 체력 상태를 시각적으로 표시하는 코드를 작성해 줘."

## PVSZ 예제: 컴포넌트를 조합하여 복잡한 UI 만들기

`PVSZ`의 화면 상단에 있는 식물 선택 UI는 여러 기본 UI 컴포넌트를 조합하고 확장하여 만들어진 좋은 예시입니다.

### 1. `UI_SelectBTNCom`: 식물 선택 카드 만들기

`UI_SelectBTNCom`은 기본 `Button` 컴포넌트를 상속받아 식물 선택 카드 하나를 구현합니다.

```cpp
// UI_SelectBTNCom.h (간략화)
class UI_SelectBTNCom : public Button // Button의 기능을 그대로 물려받음
{
public:
    virtual void Start() override;

    // 카드의 아이콘 이미지를 설정하는 함수
    void ImageLoadImage(std::wstring p_loadimg);

protected:
    // 카드의 아이콘을 그리기 위한 ImageComponent
    ImageComponent* m_IconImg;

    // 이 카드가 어떤 종류의 식물인지 저장
    E_PlantType m_CurrentPlantType;

    // 카드가 현재 선택되었는지 여부
    bool m_ISSelect = false;
};
```
`UI_SelectBTNCom`은 `Button`의 클릭 감지 기능을 상속받으면서, `ImageComponent`를 멤버로 두어 식물 아이콘을 표시하는 기능을 추가했습니다. 이처럼 기존 컴포넌트를 상속받고 다른 컴포넌트를 멤버로 포함함으로써 원하는 기능을 가진 새로운 UI 컴포넌트를 만들 수 있습니다.

### 2. `UI_TopSelectPanelCom`: 카드들을 모아 패널 만들기

`UI_TopSelectPanelCom`은 여러 개의 `UI_SelectBTNCom`을 관리하여 화면 상단의 전체 UI 패널을 구성합니다.

```cpp
// UI_TopSelectPanelCom.h (간략화)
class UI_TopSelectPanelCom : public Component
{
public:
    // 패널과 카드들을 모두 초기화하는 함수
    void InitSettings();

protected:
    // 패널의 배경 이미지를 위한 ImageComponent
    ImageComponent* m_BGTopUIImage;

    // 이 패널이 관리하는 모든 식물 선택 카드(버튼)들
    std::vector<UI_SelectBTNCom*> m_SelectBTNComVec;

    // 카드 중 하나가 클릭되었을 때 호출될 콜백 함수
    void Click_CallBackFN(Button* p_clickbtn, int p_selectid);
};

// UI_TopSelectPanelCom.cpp (간략화)
void UI_TopSelectPanelCom::InitSettings()
{
    // ... 배경 이미지 GameObject 생성 및 설정 ...

    // 게임에 등장하는 모든 식물 종류에 대해 반복
    for (int i = 0; i < (int)E_PlantType::MAX; ++i)
    {
        // 카드 GameObject 생성
        GameObject* cardObj = new GameObject(owner->GetScene());
        cardObj->transform->SetParent(owner->transform);
        cardObj->transform->setLocalPosition(i * CARD_WIDTH, 0);

        // 카드에 UI_SelectBTNCom 컴포넌트 추가
        auto* cardButton = cardObj->AddComponent<UI_SelectBTNCom>();
        cardButton->ImageLoadImage(GetPlantIconPath((E_PlantType)i));

        // 버튼 클릭 시 Click_CallBackFN이 호출되도록 콜백 등록
        cardButton->OnClickCallBack(std::bind(&UI_TopSelectPanelCom::Click_CallBackFN, this, _1, i));

        m_SelectBTNComVec.push_back(cardButton);
    }
}
```
`UI_TopSelectPanelCom`은 `Component`이지만 직접 화면에 무언가를 그리기보다는, 자식 `GameObject`로 여러 개의 `UI_SelectBTNCom`을 생성하고 관리하는 '컨테이너' 또는 '매니저'의 역할을 합니다. 이처럼 컴포넌트를 조합하고 계층적으로 구성함으로써 복잡한 UI도 체계적으로 구현할 수 있습니다.
