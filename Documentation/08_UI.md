# 8. UI 시스템: 게임과 플레이어의 상호작용

## 소개

UI(User Interface) 시스템은 플레이어가 게임과 상호작용할 수 있는 시각적인 요소들을 제공합니다. 이 프레임워크는 컴포넌트 기반으로 UI를 구축하며, `Button`과 `TextComponent`가 가장 기본적인 UI 요소입니다. 모든 UI 컴포넌트는 다른 컴포넌트와 마찬가지로 `GameObject`에 부착되어 작동합니다.

- **`Button`:** 플레이어의 마우스 클릭에 반응하는 상호작용 가능한 영역입니다.
- **`TextComponent`:** 화면에 텍스트를 표시합니다.
- **`RichTextComponent`:** `<color>`와 같은 태그를 사용하여 텍스트의 일부에 다른 스타일을 적용할 수 있는 고급 텍스트 컴포넌트입니다.

## 핵심 개념

### 이벤트 기반 상호작용

UI 시스템, 특히 `Button`은 이벤트 기반으로 작동합니다. `Button` 컴포넌트는 마우스 클릭 이벤트를 감지하고, 이 이벤트가 발생했을 때 미리 등록된 콜백 함수(Callback Function)를 실행합니다. 이를 통해 "버튼이 클릭되면 게임을 시작한다" 또는 "아이템을 구매한다"와 같은 로직을 쉽게 구현할 수 있습니다.

### 좌표계와 UI

UI 요소는 종종 게임 세계의 특정 위치가 아닌, 화면의 고정된 위치에 표시되어야 합니다. 예를 들어, 플레이어의 체력 바는 항상 화면 왼쪽 상단에 있어야 합니다.

이를 구현하는 방법에는 두 가지가 있습니다.

1.  **스크린 공간 UI:** 카메라의 움직임에 영향을 받지 않는 UI입니다. `TextComponent`의 `SetIsCameraMatrix(false)`를 호출하면 카메라 변환이 적용되지 않아 항상 같은 화면 위치에 텍스트가 렌더링됩니다.
2.  **월드 공간 UI:** 게임 세계의 일부처럼 카메라의 움직임에 따라 함께 움직이는 UI입니다. 예를 들어, 캐릭터의 머리 위에 표시되는 이름표가 여기에 해당합니다. `TextComponent`는 기본적으로 월드 공간 UI로 작동합니다.

## UI 컴포넌트 사용법

### `Button` 사용하기

`Button` 컴포넌트를 `GameObject`에 추가하고, 생성자나 `OnClickCallBack` 메서드를 통해 클릭 시 실행될 람다 함수나 일반 함수를 등록할 수 있습니다.

```cpp
// MainMenuScene.cpp
#include "Core/GameObject.h"
#include "UICompoment/Button.h"

void MainMenuScene::InitSettings()
{
    // "StartButton" GameObject 생성
    GameObject* startButtonObj = CreateObject("StartButton");
    startButtonObj->transform->setLocalPosition(350, 250); // 화면 위치 설정

    // Button 컴포넌트 추가 및 클릭 이벤트 핸들러 등록
    auto* button = startButtonObj->AddComponent<Button>([](Button* sender) {
        // 이 코드는 버튼이 클릭될 때 실행됩니다.
        // 예를 들어, 게임 씬으로 전환하는 로직을 여기에 작성합니다.
        // Game::GetInstance()->ChangeScene(new GameScene());
        MessageBox(nullptr, L"Start 버튼 클릭됨!", L"알림", MB_OK);
    });

    // 버튼의 크기 설정
    button->SetBTNSize(100, 50);
}
```

### `TextComponent` 사용하기

`TextComponent`를 사용하여 화면에 텍스트를 표시할 수 있습니다. 다양한 메서드를 통해 텍스트의 스타일을 변경할 수 있습니다.

```cpp
// HUD.cpp
#include "Core/GameObject.h"
#include "UICompoment/TextComponent.h"

void CreateHUD()
{
    // 점수 표시를 위한 GameObject 생성
    GameObject* scoreTextObj = new GameObject(this);
    scoreTextObj->SetName("ScoreText");

    auto* text = scoreTextObj->AddComponent<TextComponent>();

    // 텍스트 내용 및 스타일 설정
    text->SetText(L"Score: 0");
    text->SetFont(L"Arial", 24.0f);
    text->SetFontColor(255, 255, 255, 255); // 흰색
    text->SetSize(200, 50); // 텍스트가 표시될 영역 크기

    // 위치 설정 (카메라 영향을 받지 않는 스크린 공간)
    text->SetIsCameraMatrix(false); // 중요!
    scoreTextObj->transform->setLocalPosition(10, 10); // 화면 왼쪽 상단
}
```

### 버튼과 텍스트 조합하기

버튼 위에 텍스트를 표시하려면, `Button` `GameObject`의 자식으로 `TextComponent`를 가진 `GameObject`를 만들면 됩니다.

```cpp
// 버튼 생성
GameObject* buttonObj = CreateObject("StyledButton");
buttonObj->transform->setLocalPosition(350, 350);
auto* button = buttonObj->AddComponent<Button>();
button->SetBTNSize(120, 40);

// 버튼 위에 표시될 텍스트 생성
GameObject* textObj = CreateObject("ButtonText");
// 부모-자식 관계 설정
textObj->transform->SetParent(buttonObj->transform);

auto* text = textObj->AddComponent<TextComponent>();
text->SetText(L"Click Me!");
text->SetFont(L"Verdana", 18.0f);
text->SetSize(120, 40);
// 텍스트를 버튼 중앙에 정렬
text->SetAlignment(Gdiplus::StringAlignmentCenter, Gdiplus::StringAlignmentCenter);
```

## AI에게 할 수 있는 질문

- "`Button` 컴포넌트가 회전하거나 크기가 조절된 `GameObject`에 부착되어 있어도 마우스 클릭을 정확하게 감지할 수 있는 원리는 무엇이야?"
- "월드 공간 UI와 스크린 공간 UI의 차이점은 무엇이며, 각각 어떤 경우에 사용해야 해?"
- "`std::function`을 사용하여 버튼의 클릭 이벤트를 처리하는 방식의 장점은 무엇이야?"
- "`RichTextComponent`를 사용하여 "Hello, <color=#FFFF0000>World</color>!" 와 같이 텍스트의 일부만 색상을 변경하려면 어떻게 해야 해?"

## PVSZ 예제: 컴포넌트를 조합하여 복잡한 UI 만들기

`PVSZ`의 화면 상단에 있는 식물 선택 UI는 여러 기본 UI 컴포넌트를 조합하고 확장하여 만들어진 좋은 예시입니다.

### 1. `UI_SelectBTNCom`: 식물 선택 카드 만들기

`UI_SelectBTNCom`은 기본 `Button` 컴포넌트를 상속받아 식물 선택 카드 하나를 구현합니다.

```cpp
// UI_SelectBTNCom.h (간략화)
class UI_SelectBTNCom : public Button // Button의 기능을 그대로 물려받음
{
public:
    virtual void Start() override;

    // 카드의 아이콘 이미지를 설정하는 함수
    void ImageLoadImage(std::wstring p_loadimg);

protected:
    // 카드의 아이콘을 그리기 위한 ImageComponent
    ImageComponent* m_IconImg;

    // 이 카드가 어떤 종류의 식물인지 저장
    E_PlantType m_CurrentPlantType;

    // 카드가 현재 선택되었는지 여부
    bool m_ISSelect = false;
};
```
`UI_SelectBTNCom`은 `Button`의 클릭 감지 기능을 상속받으면서, `ImageComponent`를 멤버로 두어 식물 아이콘을 표시하는 기능을 추가했습니다. 이처럼 기존 컴포넌트를 상속받고 다른 컴포넌트를 멤버로 포함함으로써 원하는 기능을 가진 새로운 UI 컴포넌트를 만들 수 있습니다.

### 2. `UI_TopSelectPanelCom`: 카드들을 모아 패널 만들기

`UI_TopSelectPanelCom`은 여러 개의 `UI_SelectBTNCom`을 관리하여 화면 상단의 전체 UI 패널을 구성합니다.

```cpp
// UI_TopSelectPanelCom.h (간략화)
class UI_TopSelectPanelCom : public Component
{
public:
    // 패널과 카드들을 모두 초기화하는 함수
    void InitSettings();

protected:
    // 패널의 배경 이미지를 위한 ImageComponent
    ImageComponent* m_BGTopUIImage;

    // 이 패널이 관리하는 모든 식물 선택 카드(버튼)들
    std::vector<UI_SelectBTNCom*> m_SelectBTNComVec;

    // 카드 중 하나가 클릭되었을 때 호출될 콜백 함수
    void Click_CallBackFN(Button* p_clickbtn, int p_selectid);
};

// UI_TopSelectPanelCom.cpp (간략화)
void UI_TopSelectPanelCom::InitSettings()
{
    // ... 배경 이미지 GameObject 생성 및 설정 ...

    // 게임에 등장하는 모든 식물 종류에 대해 반복
    for (int i = 0; i < (int)E_PlantType::MAX; ++i)
    {
        // 카드 GameObject 생성
        GameObject* cardObj = new GameObject(owner->GetScene());
        cardObj->transform->SetParent(owner->transform);
        cardObj->transform->setLocalPosition(i * CARD_WIDTH, 0);

        // 카드에 UI_SelectBTNCom 컴포넌트 추가
        auto* cardButton = cardObj->AddComponent<UI_SelectBTNCom>();
        cardButton->ImageLoadImage(GetPlantIconPath((E_PlantType)i));

        // 버튼 클릭 시 Click_CallBackFN이 호출되도록 콜백 등록
        cardButton->OnClickCallBack(std::bind(&UI_TopSelectPanelCom::Click_CallBackFN, this, _1, i));

        m_SelectBTNComVec.push_back(cardButton);
    }
}
```
`UI_TopSelectPanelCom`은 `Component`이지만 직접 화면에 무언가를 그리기보다는, 자식 `GameObject`로 여러 개의 `UI_SelectBTNCom`을 생성하고 관리하는 '컨테이너' 또는 '매니저'의 역할을 합니다. 이처럼 컴포넌트를 조합하고 계층적으로 구성함으로써 복잡한 UI도 체계적으로 구현할 수 있습니다.
